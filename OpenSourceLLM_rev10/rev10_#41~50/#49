
# scheduler_app.py
# ---------------------------------------------
# ë¡œì»¬ Ollama(DeepSeek-R1) + Gradio UI ìŠ¤ì¼€ì¤„ëŸ¬ ë°ëª¨
# - ì´ˆê¸° ìŠ¤ì¼€ì¤„ì˜ ê³ ì • ê·¼ë¬´/íœ´ê°€ë¥¼ ì¡´ì¤‘í•˜ë©´ì„œ ë¹ˆ ì¹¸ì„ ì±„ì›Œ ë„£ìŠµë‹ˆë‹¤.
# - ì œì•½:
#     * ì§ì›ë³„ ìµœì†Œ/ìµœëŒ€ ê·¼ë¬´ì¼
#     * ì§ì›ë³„ ìµœëŒ€ ì—°ì† ê·¼ë¬´ì¼
#     * í•˜ë£¨ í•„ìš” ì¸ì› ìˆ˜(ê¸°ë³¸ 2ëª…)
# - ì•Œê³ ë¦¬ì¦˜:
#     1) ëœë¤ íœ´ë¦¬ìŠ¤í‹±(ë¹ ë¦„, ê°€ë” ì œì•½ ìœ„ë°˜ ê°€ëŠ¥ -> ìë™ ì¬ì‹œë„)
#     2) ë°±íŠ¸ë˜í‚¹(ê°€ëŠ¥í•˜ë©´ ì™„ì „í•´, ëŠë¦´ ìˆ˜ ìˆìŒ)
#     3) ìœ ì „ ì•Œê³ ë¦¬ì¦˜(ê·¼ì‚¬í•´, ë¹ ë¦„/ì•ˆì •)
# - DeepSeek-R1ë¡œ ê²°ê³¼ í•´ì„¤(ì˜µì…˜)
# ---------------------------------------------

from __future__ import annotations
import random
import itertools
from typing import List, Optional, Tuple, Dict
import copy
import json
import gradio as gr
import requests

WORK = "â—"      # ê·¼ë¬´
OFF  = "íœ´ê°€"   # íœ´ê°€

# -----------------------------
# ìœ í‹¸: íŒŒì‹±/í‘œí˜„ ë³€í™˜
# -----------------------------
def parse_initial_schedule(text: str) -> List[List[Optional[str]]]:
    """
    ì…ë ¥ í˜•ì‹(ì˜ˆ):
      â—, , , , , , 
      , , íœ´ê°€, , , íœ´ê°€, 
      â—, , , , , â—, 
    - ì½¤ë§ˆ/ê³µë°± êµ¬ë¶„, ì¤„ë°”ê¿ˆìœ¼ë¡œ í–‰ êµ¬ë¶„
    - 'â—' -> ê³ ì • ê·¼ë¬´, 'íœ´ê°€' -> ê³ ì • íœ´ê°€, ë¹ˆì¹¸/./None -> ë¯¸ì •(None)
    """
    rows = []
    for line in text.strip().splitlines():
        if not line.strip():
            continue
        tokens = [t.strip() for t in line.split(",")]
        row = []
        for t in tokens:
            if t in ["", ".", "None", "none", "null", "-"]:
                row.append(None)
            elif t == WORK:
                row.append(WORK)
            elif t == OFF:
                row.append(OFF)
            else:
                # ì•Œ ìˆ˜ ì—†ëŠ” í† í°ì€ Noneìœ¼ë¡œ ì²˜ë¦¬
                row.append(None)
        rows.append(row)
    # ì§ì‚¬ê°í˜• ë³´ì •(ìµœëŒ€ ê¸¸ì´ì— ë§ì¶° None íŒ¨ë”©)
    max_len = max(len(r) for r in rows)
    for r in rows:
        if len(r) < max_len:
            r.extend([None]*(max_len - len(r)))
    return rows

def to_symbols(matrix01: List[List[int]]) -> List[List[str]]:
    return [[WORK if v == 1 else OFF for v in row] for row in matrix01]

def from_symbols(initial: List[List[Optional[str]]]) -> List[List[Optional[int]]]:
    """
    'â—' -> 1, 'íœ´ê°€' -> 0, None -> None
    """
    out = []
    for r in initial:
        row = []
        for v in r:
            if v == WORK:
                row.append(1)
            elif v == OFF:
                row.append(0)
            else:
                row.append(None)
        out.append(row)
    return out

def stringify_schedule(sym: List[List[str]]) -> str:
    return "\n".join([", ".join(row) for row in sym])

# -----------------------------
# ì œì•½ ê²€ì‚¬/í†µê³„
# -----------------------------
def staff_work_days(sol: List[List[int]], staff: int) -> int:
    return sum(1 for d in sol[staff] if d == 1)

def consecutive_limit_ok(sol: List[List[int]], staff: int, day: int, max_consec: int) -> bool:
    """
    day ìœ„ì¹˜ê¹Œì§€ ë°°ì •ëœ ìƒíƒœì—ì„œ staffì˜ ì—°ì† ê·¼ë¬´ê°€ max_consecë¥¼ ë„˜ëŠ”ì§€ ê²€ì‚¬
    """
    cnt = 0
    for d in range(day, -1, -1):
        if sol[staff][d] == 1:
            cnt += 1
        else:
            break
    return cnt <= max_consec

def day_staff_count(sol: List[List[int]], day: int) -> int:
    return sum(sol[s][day] for s in range(len(sol)))

def is_complete_and_valid(sol: List[List[int]],
                          min_w: int, max_w: int, max_consec: int,
                          need_per_day: int) -> bool:
    S, D = len(sol), len(sol[0])
    # ì§ì›ë³„ ê·¼ë¬´ì¼ìˆ˜ ì œì•½
    for s in range(S):
        w = staff_work_days(sol, s)
        if not (min_w <= w <= max_w):
            return False
        # ì—°ì† ê·¼ë¬´ ê²€ì¦
        consec = 0
        for d in range(D):
            if sol[s][d] == 1:
                consec += 1
                if consec > max_consec:
                    return False
            else:
                consec = 0
    # ì¼ë³„ í•„ìš” ì¸ì›
    for d in range(D):
        if day_staff_count(sol, d) != need_per_day:
            return False
    return True

# -----------------------------
# ê³ ì • ë°°ì • ë°˜ì˜
# -----------------------------
def apply_fixtures(initial01: List[List[Optional[int]]]) -> List[List[int]]:
    """
    ì´ˆê¸° ìŠ¤ì¼€ì¤„ì—ì„œ ê³ ì •ê°’(1 ë˜ëŠ” 0)ì„ ë°˜ì˜, Noneì€ -1ë¡œ ì±„ì›Œ ë°°ì • ì „ ìƒíƒœë¥¼ í‘œì‹œ
    """
    sol = []
    for r in initial01:
        sol.append([v if v is not None else -1 for v in r])
    return sol

def is_cell_fixed(initial01: List[List[Optional[int]]], s: int, d: int) -> bool:
    return initial01[s][d] is not None

# -----------------------------
# 1) ëœë¤ íœ´ë¦¬ìŠ¤í‹±
# -----------------------------
def random_construct(initial01: List[List[Optional[int]]],
                     min_w: int, max_w: int, max_consec: int,
                     need_per_day: int,
                     max_trials: int = 2000) -> Optional[List[List[int]]]:
    """
    ê°„ë‹¨í•œ íƒìš•+ëœë¤: í•˜ë£¨ ë‹¨ìœ„ë¡œ need_per_day ëª…ì„ ë½‘ì•„ ì±„ì›€.
    ì œì•½ ìœ„ë°˜ ìµœì†Œí™”í•˜ë©° ì¬ì‹œë„ ë°˜ë³µ.
    """
    S, D = len(initial01), len(initial01[0])
    for _ in range(max_trials):
        sol = apply_fixtures(initial01)
        # ì§ì›ë³„ í˜„ì¬ ê·¼ë¬´ì¼ìˆ˜ ì¶”ì 
        workdays = [sum(1 for v in row if v == 1) for row in sol]

        ok = True
        for d in range(D):
            # ì´ë¯¸ ê³ ì •ê°’ìœ¼ë¡œ ì±„ì›Œì§„ ì¸ì› ì¹´ìš´íŠ¸
            fixed_workers = [s for s in range(S) if sol[s][d] == 1]
            if len(fixed_workers) > need_per_day:
                ok = False; break

            # ë°°ì • ê°€ëŠ¥í•œ í›„ë³´ í’€ ë§Œë“¤ê¸°
            candidates = []
            for s in range(S):
                if sol[s][d] == -1:  # ë¯¸ì •
                    # ì—°ì† ê·¼ë¬´ ì œí•œ ê²€ì‚¬(ê°€ìƒìœ¼ë¡œ 1 ë„£ê³  í™•ì¸)
                    sol[s][d] = 1
                    if consecutive_limit_ok(sol, s, d, max_consec):
                        candidates.append(s)
                    sol[s][d] = -1

            # í•„ìš”í•œ ì¸ì›ìˆ˜ë§Œí¼ ë½‘ê¸°(ê³ ì • í¬í•¨)
            need = need_per_day - len(fixed_workers)
            if need < 0:
                ok = False; break
            if need > len(candidates):
                # ë¶€ì¡±í•˜ë©´ ì‹¤íŒ¨ë¡œ ê°„ì£¼í•˜ê³  ì¬ì‹œë„
                ok = False; break

            # ì‘ì—…ëŸ‰ì´ ì ì€ ì‚¬ëŒ ìš°ëŒ€(+ëœë¤ ì„ê¸°)
            random.shuffle(candidates)
            candidates.sort(key=lambda s: workdays[s])
            pick = candidates[:need]

            # í™•ì • ë°˜ì˜
            for s in range(S):
                if sol[s][d] == -1:
                    sol[s][d] = 1 if s in pick else 0

            # workdays ê°±ì‹ 
            for s in pick:
                workdays[s] += 1

            # ì¼ë³„ ì¶©ì¡± í™•ì¸
            if day_staff_count(sol, d) != need_per_day:
                ok = False; break

        if not ok:
            continue

        # ê°œì¸ë³„ ìµœì†Œ/ìµœëŒ€ ê·¼ë¬´ì¼ ì¡°ì •(ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„)
        for s in range(S):
            w = staff_work_days(sol, s)
            if w < min_w or w > max_w:
                ok = False; break
        if not ok:
            continue

        return sol
    return None

# -----------------------------
# 2) ë°±íŠ¸ë˜í‚¹(ì™„ì „ íƒìƒ‰)
# -----------------------------
def backtracking(initial01: List[List[Optional[int]]],
                 min_w: int, max_w: int, max_consec: int,
                 need_per_day: int,
                 max_solutions: int = 1) -> List[List[List[int]]]:
    S, D = len(initial01), len(initial01[0])
    sol = apply_fixtures(initial01)
    solutions = []

    # ë¯¸ì • ìœ„ì¹˜ ì¸ë±ìŠ¤ ëª©ë¡(ì¼ ë‹¨ìœ„ ì¡°í•©ì„ ìœ„í•´ day ë³„ë¡œ ì²˜ë¦¬)
    days = list(range(D))

    # ì‚¬ì „ ê³ ì • ê²€ì¦: ê° ë‚ ì§œ ê³ ì • ê·¼ë¬´ì ìˆ˜ê°€ need_per_day ì´ˆê³¼ë©´ ë¶ˆê°€
    for d in days:
        if sum(1 for s in range(S) if initial01[s][d] == 1) > need_per_day:
            return []

    def dfs(day: int):
        if len(solutions) >= max_solutions:
            return
        if day == D:
            if is_complete_and_valid(sol, min_w, max_w, max_consec, need_per_day):
                solutions.append(copy.deepcopy(sol))
            return

        fixed_yes = [s for s in range(S) if initial01[s][day] == 1]
        fixed_no  = [s for s in range(S) if initial01[s][day] == 0]
        remain = need_per_day - len(fixed_yes)
        if remain < 0:
            return

        # í›„ë³´ = ë¯¸ì •ì´ë©´ì„œ ì˜¤ëŠ˜ ë°°ì • ê°€ëŠ¥í•˜ê³ (ì—°ì†ê·¼ë¬´ OK) ì§ì›ë³„ max_w ë¯¸ì´ˆê³¼
        candidates = []
        for s in range(S):
            if initial01[s][day] is None:
                # ì„ì‹œë¡œ 1 ë„£ê³  ì—°ì†ê·¼ë¬´ ê²€ì‚¬
                sol[s][day] = 1
                cons_ok = consecutive_limit_ok(sol, s, day, max_consec)
                sol[s][day] = -1
                if cons_ok and staff_work_days(sol, s) < max_w:
                    candidates.append(s)

        # ë‚¨ì€ ì¸ì› ìˆ˜ë§Œí¼ ì¡°í•©
        for pick in itertools.combinations(candidates, remain):
            # í•˜ë£¨ ë°°ì • ì‹œë„
            # 1) ê³ ì • YESëŠ” 1, pickì€ 1, ë‚˜ë¨¸ì§€ëŠ” 0
            for s in range(S):
                if initial01[s][day] == 1 or s in pick:
                    sol[s][day] = 1
                elif initial01[s][day] == 0:
                    sol[s][day] = 0
                else:
                    sol[s][day] = 0  # ê¸°ë³¸ 0ë¡œ ì„¤ì •

            # ì—°ì†ê·¼ë¬´ ìœ„ë°˜/ë¶€ë¶„ì  ìƒí•œ ìœ„ë°˜ ë¹ ë¥¸ ê°€ì§€ì¹˜ê¸°
            bad = False
            for s in range(S):
                if not consecutive_limit_ok(sol, s, day, max_consec):
                    bad = True; break
                # ë‚¨ì€ ë‚ ì„ ëª¨ë‘ ì‰¬ì–´ë„ min_wë¥¼ ëª» ë§ì¶œ ìˆ˜ ìˆìœ¼ë©´ ì»·
                assigned = staff_work_days(sol, s)
                remaining_days = D - (day + 1)
                max_possible = assigned + remaining_days
                if assigned > max_w or max_possible < min_w:
                    bad = True; break
            if bad:
                continue

            dfs(day + 1)

            if len(solutions) >= max_solutions:
                return

    dfs(0)
    return solutions

# -----------------------------
# 3) ìœ ì „ ì•Œê³ ë¦¬ì¦˜
# -----------------------------
def fitness(sol: List[List[int]],
           initial01: List[List[Optional[int]]],
           min_w: int, max_w: int, max_consec: int, need_per_day: int) -> float:
    S, D = len(sol), len(sol[0])
    score = 0.0

    # ê³ ì • ìœ„ë°˜ í° í˜ë„í‹°
    for s in range(S):
        for d in range(D):
            if initial01[s][d] is not None and sol[s][d] != initial01[s][d]:
                score -= 5.0

    # ì¼ë³„ í•„ìš” ì¸ì› í¸ì°¨ í˜ë„í‹°
    for d in range(D):
        diff = abs(day_staff_count(sol, d) - need_per_day)
        score -= 2.0 * diff

    # ì§ì›ë³„ ê·¼ë¬´ì¼ í—ˆìš© ë²”ìœ„ì—ì„œ ë³´ìƒ, ë²—ì–´ë‚˜ë©´ í˜ë„í‹°
    for s in range(S):
        w = staff_work_days(sol, s)
        if min_w <= w <= max_w:
            score += 1.0 * w
        else:
            score -= 1.5 * abs((min_w if w < min_w else max_w) - w)

        # ì—°ì†ê·¼ë¬´ ìœ„ë°˜ í˜ë„í‹°
        consec = 0
        for d in range(D):
            if sol[s][d] == 1:
                consec += 1
                if consec > max_consec:
                    score -= 2.5
            else:
                consec = 0
    # ì•„ì£¼ ì‘ì€ ì–‘ìˆ˜ ë³´ì •(ì„ íƒ ê°€ì¤‘ì¹˜ìš©)
    return max(score, 0.0001)

def ga_solve(initial01: List[List[Optional[int]]],
             min_w: int, max_w: int, max_consec: int, need_per_day: int,
             pop_size: int = 80, generations: int = 150, mutation_rate: float = 0.08,
             seed: Optional[int] = None) -> List[List[int]]:
    if seed is not None:
        random.seed(seed)
    S, D = len(initial01), len(initial01[0])

    # ì´ˆê¸°ê°œì²´: ê³ ì •ê°’ì€ ê·¸ëŒ€ë¡œ, ë¯¸ì •ì€ ëœë¤(ì¼ë³„ need_per_day ë§ì¶”ë„ë¡ ê°„ë‹¨ ì¡°ì •)
    def random_individual():
        ind = [[(initial01[s][d] if initial01[s][d] is not None else 0) for d in range(D)] for s in range(S)]
        for d in range(D):
            fixed_yes = [s for s in range(S) if ind[s][d] == 1]
            remain = need_per_day - len(fixed_yes)
            if remain < 0:
                # ë¶ˆê°€ëŠ¥í•œ ì´ˆê¸°ì¡°ê±´ì´ë©´, ê³ ì • ìœ„ë°˜ì„ ìµœì†Œí™”í•˜ë„ë¡ 1ë“¤ì„ ì¼ë¶€ 0ìœ¼ë¡œ
                ones = [s for s in fixed_yes]
                for s in ones[remain:]:
                    if initial01[s][d] is None:
                        ind[s][d] = 0
            elif remain > 0:
                pool = [s for s in range(S) if initial01[s][d] is None]
                pick = random.sample(pool, k=min(remain, len(pool))) if pool else []
                for s in pick:
                    ind[s][d] = 1
        return ind

    population = [random_individual() for _ in range(pop_size)]

    def crossover(p1, p2):
        # í•œ ì  êµì°¨(ì§ì›*ì¼ flatten ì¸ë±ìŠ¤)
        cut = random.randint(0, S*D - 1)
        c1 = copy.deepcopy(p1)
        c2 = copy.deepcopy(p2)
        for idx in range(cut, S*D):
            r = idx // D
            c = idx % D
            # ê³ ì •ê°’ì€ êµì°¨ ì˜í–¥ ê¸ˆì§€
            if initial01[r][c] is None:
                c1[r][c], c2[r][c] = c2[r][c], c1[r][c]
        return c1, c2

    def mutate(ind):
        for s in range(S):
            for d in range(D):
                if initial01[s][d] is None and random.random() < mutation_rate:
                    ind[s][d] = 1 - ind[s][d]
        return ind

    for _ in range(generations):
        fitnesses = [fitness(ind, initial01, min_w, max_w, max_consec, need_per_day) for ind in population]
        # ì„ íƒ(í™•ë¥ ë¹„ë¡€ ìƒ˜í”Œë§)
        parents = random.choices(population, weights=fitnesses, k=pop_size)
        # êµì°¨ + ëŒì—°ë³€ì´
        offspring = []
        for i in range(0, pop_size, 2):
            p1, p2 = parents[i], parents[(i+1) % pop_size]
            c1, c2 = crossover(p1, p2)
            offspring.append(mutate(c1))
            offspring.append(mutate(c2))
        population = offspring

    # ìµœì  ê°œì²´ ë°˜í™˜
    best = max(population, key=lambda ind: fitness(ind, initial01, min_w, max_w, max_consec, need_per_day))
    return best

# -----------------------------
# DeepSeek-R1 í•´ì„¤ (Ollama)
# -----------------------------
def deepseek_explain(schedule_sym: List[List[str]], params: Dict, host: str = "http://localhost:11434", model: str = "deepseek-r1") -> str:
    """
    Ollama generate API í˜¸ì¶œ(ë¡œì»¬). ì„¤ì¹˜ í•„ìš”: `ollama pull deepseek-r1`
    """
    try:
        prompt = (
            "ë‹¤ìŒ ê·¼ë¬´ ìŠ¤ì¼€ì¤„ì„ í•œêµ­ì–´ë¡œ ê°„ê²°í•˜ê²Œ í•´ì„¤í•˜ê³ , ì œì•½(ìµœì†Œ/ìµœëŒ€ ê·¼ë¬´ì¼, ìµœëŒ€ ì—°ì†ê·¼ë¬´, ì¼ì¼ í•„ìš” ì¸ì›) ë§Œì¡± ì—¬ë¶€ë¥¼ ìš”ì•½í•´ ì£¼ì„¸ìš”.\n"
            f"íŒŒë¼ë¯¸í„°: {json.dumps(params, ensure_ascii=False)}\n"
            f"ìŠ¤ì¼€ì¤„(í–‰=ì§ì›, ì—´=ìš”ì¼):\n{stringify_schedule(schedule_sym)}"
        )
        resp = requests.post(
            f"{host}/api/generate",
            json={"model": model, "prompt": prompt, "stream": False},
            timeout=30
        )
        if resp.status_code == 200:
            data = resp.json()
            # OllamaëŠ” {"response": "...", "done": true, ...} í˜•íƒœ
            return data.get("response", "").strip()
        else:
            return f"[DeepSeek-R1 í˜¸ì¶œ ì‹¤íŒ¨] status={resp.status_code}, body={resp.text[:200]}"
    except Exception as e:
        return f"[DeepSeek-R1 ì˜ˆì™¸] {e}"

# -----------------------------
# ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜(Gradio ì—°ë™)
# -----------------------------
def generate_ui(initial_text: str,
                algo: str,
                min_work_days: int,
                max_work_days: int,
                max_consec_days: int,
                need_per_day: int,
                max_backtrack_solutions: int,
                ga_pop: int,
                ga_gen: int,
                ga_mut: float,
                use_llm: bool) -> Tuple[str, str]:
    """
    ë°˜í™˜:
      - ìŠ¤ì¼€ì¤„(ë¬¸ìì—´ í‘œ)
      - LLM í•´ì„¤(ì˜µì…˜)
    """
    # ì…ë ¥ íŒŒì‹±
    init_sym = parse_initial_schedule(initial_text)
    if not init_sym:
        return "ì´ˆê¸° ìŠ¤ì¼€ì¤„ íŒŒì‹± ì‹¤íŒ¨: ì…ë ¥ì„ í™•ì¸í•˜ì„¸ìš”.", ""

    initial01 = from_symbols(init_sym)

    # íŒŒë¼ë¯¸í„° sanity check
    S, D = len(initial01), len(initial01[0])
    # ì‚¬ì „ ë¶ˆê°€ëŠ¥ ê²€ì‚¬: ì–´ë–¤ ë‚  ê³ ì • 1ì˜ ìˆ˜ê°€ need_per_day ì´ˆê³¼ë©´ ë°”ë¡œ ì‹¤íŒ¨
    for d in range(D):
        if sum(1 for s in range(S) if initial01[s][d] == 1) > need_per_day:
            return f"ë¶ˆê°€ëŠ¥: {d+1}ì¼ì°¨ ê³ ì • ê·¼ë¬´ ì¸ì›ì´ í•„ìš” ì¸ì›({need_per_day})ì„ ì´ˆê³¼í•©ë‹ˆë‹¤.", ""

    result01 = None
    if algo == "ëœë¤(íœ´ë¦¬ìŠ¤í‹±)":
        result01 = random_construct(initial01, min_work_days, max_work_days, max_consec_days, need_per_day)
        if result01 is None:
            return "ëœë¤ êµ¬ì„±ìœ¼ë¡œ ìœ íš¨í•œ ìŠ¤ì¼€ì¤„ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íŒŒë¼ë¯¸í„°ë¥¼ ì¡°ì •í•˜ê±°ë‚˜ ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ì„ ì‹œë„í•˜ì„¸ìš”.", ""
    elif algo == "ë°±íŠ¸ë˜í‚¹(ì™„ì „ íƒìƒ‰)":
        sols = backtracking(initial01, min_work_days, max_work_days, max_consec_days, need_per_day, max_solutions=max_backtrack_solutions)
        if not sols:
            return "ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ í•´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íŒŒë¼ë¯¸í„°ë¥¼ ì¡°ì •í•´ë³´ì„¸ìš”.", ""
        result01 = sols[0]
    else:  # ìœ ì „ ì•Œê³ ë¦¬ì¦˜
        result01 = ga_solve(initial01, min_work_days, max_work_days, max_consec_days, need_per_day,
                            pop_size=ga_pop, generations=ga_gen, mutation_rate=ga_mut)
        # GAëŠ” ì œì•½ ê·¼ì‚¬ì´ë¯€ë¡œ, ìµœì¢… ê²€ì¦ í›„ ì¼ë³„ ì¸ì›/ì—°ì†ì œì•½ ë“± ë¯¸ì¶©ì¡± ì‹œ ì•ˆë‚´
        # (ì—„ê²©íˆ í•„ìš”í•˜ë©´ í›„ì²˜ë¦¬ ìˆ˜ì„  ë¡œì§ì„ ì¶”ê°€ ê°€ëŠ¥)
    result_sym = to_symbols(result01)

    table = stringify_schedule(result_sym)

    explain = ""
    if use_llm:
        params = dict(
            algorithm=algo,
            min_work_days=min_work_days,
            max_work_days=max_work_days,
            max_consecutive_work_days=max_consec_days,
            need_per_day=need_per_day,
            staff=len(result01),
            days=len(result01[0]),
        )
        explain = deepseek_explain(result_sym, params)

    return table, explain

# -----------------------------
# Gradio ì•±
# -----------------------------
EXAMPLE = """â—, , , , , , 
 , , íœ´ê°€, , , íœ´ê°€, 
 â—, , , , , â—, 
"""

with gr.Blocks(title="OpenCode - ê·¼ë¬´ ìŠ¤ì¼€ì¤„ëŸ¬ (Ollama + DeepSeek-R1)") as demo:
    gr.Markdown("## ğŸ—“ï¸ OpenCode ê·¼ë¬´ ìŠ¤ì¼€ì¤„ëŸ¬\në¡œì»¬ **Ollama + DeepSeek-R1**ê³¼ **Gradio**ë¡œ ë™ì‘í•©ë‹ˆë‹¤. ì´ˆê¸° ìŠ¤ì¼€ì¤„ê³¼ ì œì•½ì„ ë„£ê³  í•´ë¥¼ ìƒì„±í•´ ë³´ì„¸ìš”.")

    with gr.Row():
        initial_text = gr.Textbox(label="ì´ˆê¸° ìŠ¤ì¼€ì¤„(í–‰=ì§ì›, ì—´=ìš”ì¼): ì½¤ë§ˆ êµ¬ë¶„, ë¹ˆì¹¸/./None=ë¯¸ì •, 'â—'=ê³ ì • ê·¼ë¬´, 'íœ´ê°€'=ê³ ì • íœ´ê°€", lines=8, value=EXAMPLE)
        with gr.Column():
            algo = gr.Radio(choices=["ëœë¤(íœ´ë¦¬ìŠ¤í‹±)", "ë°±íŠ¸ë˜í‚¹(ì™„ì „ íƒìƒ‰)", "ìœ ì „ ì•Œê³ ë¦¬ì¦˜"], value="ëœë¤(íœ´ë¦¬ìŠ¤í‹±)", label="ì•Œê³ ë¦¬ì¦˜ ì„ íƒ")
            min_work_days = gr.Slider(0, 7, value=3, step=1, label="ì§ì›ë³„ ìµœì†Œ ê·¼ë¬´ì¼")
            max_work_days = gr.Slider(0, 7, value=5, step=1, label="ì§ì›ë³„ ìµœëŒ€ ê·¼ë¬´ì¼")
            max_consec_days = gr.Slider(1, 7, value=5, step=1, label="ìµœëŒ€ ì—°ì† ê·¼ë¬´ì¼")
            need_per_day = gr.Slider(0, 7, value=2, step=1, label="í•˜ë£¨ í•„ìš” ì¸ì› ìˆ˜")
            use_llm = gr.Checkbox(value=False, label="DeepSeek-R1ë¡œ ê²°ê³¼ í•´ì„¤ ìš”ì²­")

    with gr.Row():
        max_backtrack_solutions = gr.Slider(1, 10, value=1, step=1, label="[ë°±íŠ¸ë˜í‚¹] ì°¾ì„ í•´ì˜ ê°œìˆ˜(ìµœëŒ€)")
        ga_pop = gr.Slider(10, 300, value=80, step=10, label="[GA] ê°œì²´ìˆ˜(population)")
        ga_gen = gr.Slider(10, 500, value=150, step=10, label="[GA] ì„¸ëŒ€ ìˆ˜(generations)")
        ga_mut = gr.Slider(0.0, 0.5, value=0.08, step=0.01, label="[GA] ëŒì—°ë³€ì´ìœ¨")

    btn = gr.Button("ìŠ¤ì¼€ì¤„ ìƒì„±")

    out_table = gr.Textbox(label="ìƒì„±ëœ ìŠ¤ì¼€ì¤„(â—=ê·¼ë¬´ / íœ´ê°€)", lines=10)
    out_explain = gr.Textbox(label="DeepSeek-R1 í•´ì„¤(ì˜µì…˜)", lines=10)

    btn.click(
        fn=generate_ui,
        inputs=[initial_text, algo, min_work_days, max_work_days, max_consec_days, need_per_day,
                max_backtrack_solutions, ga_pop, ga_gen, ga_mut, use_llm],
        outputs=[out_table, out_explain]
    )

if __name__ == "__main__":
    demo.launch()


